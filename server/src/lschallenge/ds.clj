(ns lschallenge.ds
  (:use compojure.core)
  (:require [clojure.java.jdbc :as jdbc]
            [clojure.tools.logging :as log])
  (:import [com.jolbox.bonecp BoneCPDataSource]))

;; TODO: Hardcoding this makes me sad. Fix it.
;; TODO: Setting up a DataSource as a side-effect of loading this file seems bad.
;; TODO: Somehow, the data source needs to get cleaned up...
(def ds (doto (BoneCPDataSource.)
          (.setUsername "sa")
          (.setPassword "")
          (.setJdbcUrl "jdbc:hsqldb:mem:lschallenge")))

(def db {:datasource ds})

(defn create-tables [db]
  (try
    (jdbc/db-do-commands db
                         (jdbc/create-table-ddl
                          :person
                          [:id :bigint "GENERATED BY DEFAULT AS IDENTITY" "PRIMARY KEY"]
                          [:name "varchar(100)" "NOT NULL"]
                          #_[:address_id :bigint "NULL" "FOREIGN KEY" "references" :address "(" :id ")"])
                         (jdbc/create-table-ddl
                          :address
                          [:id :bigint "GENERATED BY DEFAULT AS IDENTITY" "PRIMARY KEY"]
                          [:address "varchar(255)" "NOT NULL"]
                          [:person_id :bigint "FOREIGN KEY" "references" :person "(" :id ")"])
                         (jdbc/create-table-ddl
                          :item
                          [:id :bigint "GENERATED BY DEFAULT AS IDENTITY" "PRIMARY KEY"]
                          [:name "varchar(100)" "NOT NULL"]
                          [:price :bigint "NOT NULL"])
                         (jdbc/create-table-ddl
                          :purchase
                          [:id :bigint "GENERATED BY DEFAULT AS IDENTITY" "PRIMARY KEY"]
                          [:purchaser_id :bigint "FOREIGN KEY" "references" :person "(" :id ")"]
                          [:merchant_id :bigint "FOREIGN KEY" "references" :person "(" :id ")"]
                          [:item_id :bigint "FOREIGN KEY" "references" :item "(" :id ")"]
                          [:item_count :integer "NOT NULL"]))
    (catch Exception ex
      ;; This is a hack. If the tables already exist we'll get an exception,
      ;; so we just ignore it. In reality, we shouldn't be creating the
      ;; database tables at all (they should already exist), but this is just
      ;; for demonstrative purposes.
      (log/error ex "Could not create tables"))))

(defn drop-data [db]
  (dorun (->> ["purchase" "address" "person" "item"]
              (map #(str "DELETE FROM " %))
              (map vector)
              (map jdbc/execute! (repeat db)))))

(defn dump-db [db]
  (->> ["purchase" "address" "person" "item"]
       (map #(vector (keyword %)
                     (->> (jdbc/query db [(str "select * from " %)])
                          (map (juxt :id identity ))
                          (into {}))))
       (into {})))

;; TODO: Make this not executed every time the namespace is loaded.
(create-tables db)
